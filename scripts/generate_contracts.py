"""Generate JSON Schema and TypeScript definitions for shared contracts."""
from __future__ import annotations

import json
import sys
from pathlib import Path
from typing import Any, Dict, Type

from pydantic import BaseModel

ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.append(str(ROOT))

from backend.app.contracts.models import AnalysisJobContract, AuditReportContract


SCHEMA_DIR = Path("backend/app/contracts/schemas")
TS_PATH = Path("src/types/contracts.d.ts")
MANIFEST_PATH = Path("reports/contracts_manifest.json")


def _json_schema(model: Type[BaseModel]) -> Dict[str, Any]:
    try:  # Pydantic v2
        return model.model_json_schema(by_alias=True)
    except AttributeError:  # pragma: no cover - compatibility with v1
        return model.schema(by_alias=True)


def _write_schema(model: Type[BaseModel], name: str) -> Path:
    schema = _json_schema(model)
    SCHEMA_DIR.mkdir(parents=True, exist_ok=True)
    path = SCHEMA_DIR / f"{name}.json"
    path.write_text(json.dumps(schema, indent=2, sort_keys=True), encoding="utf-8")
    return path


TS_TEMPLATE = """// ---------------------------------------------------------------------------
// This file is auto-generated by scripts/generate_contracts.py
// ---------------------------------------------------------------------------

export type AgentStatus = 'pending' | 'running' | 'completed' | 'error';
export type JobStatus = 'queued' | 'running' | 'completed' | 'failed';

export interface AgentProgressContract {
  step?: string;
  current?: number;
  total?: number;
  extra?: Record<string, unknown>;
}

export interface AgentStateContract {
  status: AgentStatus;
  progress?: AgentProgressContract;
  details?: Record<string, unknown>;
  [key: string]: unknown;
}

export type ChartType = 'bar' | 'pie' | 'line' | 'scatter';

export interface ChartDataPointContract {
  label: string;
  value: number;
  x?: number;
  color?: string;
}

export interface ChartDataContract {
  type: ChartType;
  title: string;
  data: ChartDataPointContract[];
  options?: Record<string, unknown>;
  xAxisLabel?: string;
  yAxisLabel?: string;
}

export interface ChatMessageContract {
  id: string;
  sender: 'user' | 'ai';
  text: string;
  chartData?: ChartDataContract;
}

export interface KeyMetricContract {
  metric: string;
  value: string;
  insight: string;
}

export interface AnalysisResultContract {
  title: string;
  summary: string;
  keyMetrics: KeyMetricContract[];
  actionableInsights: string[];
  strategicRecommendations?: string[];
}

export type ImportedDocKind = 'NFE_XML' | 'CSV' | 'XLSX' | 'PDF' | 'IMAGE' | 'UNSUPPORTED';
export type ImportedDocStatus = 'parsed' | 'ocr_needed' | 'unsupported' | 'error';

export interface ImportedDocContract {
  kind: ImportedDocKind;
  name: string;
  size: number;
  status: ImportedDocStatus;
  data?: Record<string, string | number>[];
  text?: string;
  meta?: Record<string, string | number>;
  error?: string;
}

export type InconsistencySeverity = 'ERRO' | 'ALERTA' | 'INFO';

export interface InconsistencyContract {
  code: string;
  message: string;
  explanation: string;
  normativeBase?: string;
  severity: InconsistencySeverity;
}

export type OperationType = 'Compra' | 'Venda' | 'Devolução' | 'Serviço' | 'Transferência' | 'Outros';

export interface ClassificationResultContract {
  operationType: OperationType;
  businessSector: string;
  confidence: number;
}

export interface AuditedDocumentContract {
  doc: ImportedDocContract;
  status: 'OK' | 'ALERTA' | 'ERRO';
  score?: number;
  inconsistencies: InconsistencyContract[];
  classification?: ClassificationResultContract;
}

export interface AccountingEntryContract {
  docName: string;
  account: string;
  type: 'D' | 'C';
  value: number;
}

export interface SpedFileContract {
  filename: string;
  content: string;
}

export interface CrossValidationDocumentContract {
  name: string;
  value: string | number;
}

export interface CrossValidationResultContract {
  attribute: string;
  observation: string;
  documents: CrossValidationDocumentContract[];
}

export type DeterministicSeverity = 'ALERTA' | 'INFO';

export interface DeterministicDiscrepancyContract {
  valueA: string | number;
  docA: Record<string, string | number>;
  valueB: string | number;
  docB: Record<string, string | number>;
  ruleCode: string;
  justification: string;
}

export interface DeterministicContextSnapshotContract {
  ncm: string;
  cfop: string;
  emitenteCnpj?: string;
  destinatarioCnpj?: string;
  dataEmissao?: string;
  produtoNome?: string;
}

export interface DeterministicCrossValidationResultContract {
  comparisonKey: string;
  attribute: string;
  description: string;
  discrepancies: DeterministicDiscrepancyContract[];
  severity: DeterministicSeverity;
  ruleCode: string;
  justification: string;
  context: DeterministicContextSnapshotContract;
}

export type DeterministicArtifactFormat = 'json' | 'csv' | 'md';

export interface DeterministicArtifactDescriptorContract {
  executionId: string;
  format: DeterministicArtifactFormat;
  filename: string;
  createdAt: string;
  size: number;
}

export interface AuditReportContract {
  summary: AnalysisResultContract;
  documents: AuditedDocumentContract[];
  aggregatedMetrics?: Record<string, string | number>;
  accountingEntries?: AccountingEntryContract[];
  spedFile?: SpedFileContract;
  aiDrivenInsights?: Record<string, unknown>[];
  crossValidationResults?: CrossValidationResultContract[];
  deterministicCrossValidation?: DeterministicCrossValidationResultContract[];
  deterministicArtifacts?: DeterministicArtifactDescriptorContract[];
  executionId?: string;
}

export interface AnalysisJobContract {
  jobId: string;
  status: JobStatus;
  agentStates: Record<string, AgentStateContract>;
  error?: string | null;
  result?: AuditReportContract | null;
  createdAt?: string | null;
  updatedAt?: string | null;
}
"""


def _write_typescript() -> Path:
    TS_PATH.parent.mkdir(parents=True, exist_ok=True)
    TS_PATH.write_text(TS_TEMPLATE.strip() + "\n", encoding="utf-8")
    return TS_PATH


def main() -> None:
    job_schema = _write_schema(AnalysisJobContract, "analysis_job")
    report_schema = _write_schema(AuditReportContract, "audit_report")
    ts_file = _write_typescript()

    manifest = {
        "schemas": {
            "analysis_job": str(job_schema),
            "audit_report": str(report_schema),
        },
        "typescript": str(ts_file),
        "models": [
            "backend.app.contracts.models.AnalysisJobContract",
            "backend.app.contracts.models.AuditReportContract",
        ],
    }

    MANIFEST_PATH.parent.mkdir(parents=True, exist_ok=True)
    MANIFEST_PATH.write_text(json.dumps(manifest, indent=2, sort_keys=True), encoding="utf-8")


if __name__ == "__main__":
    main()
